constant
  af_inet
    2

constant
  af_inet6
    10

constant
  sock_stream
    1

constant
  default_protocol
    0

constant
  ai_passive
    1

struct
  sockaddr
    sa_family: i16,
    sa_data: array(i8, 14),

struct
  addrinfo
    ai_flags: i32,
    ai_family: i32,
    ai_socktype: i32,
    ai_protocol: i32,
    ai_addrlen: u32,
    ai_addr: ptr(sockaddr),
    ai_canonname: ptr(i8),
    ai_next: ptr(addrinfo),

extern
  getaddrinfo
    <-
      ptr(i8),
      ptr(i8),
      ptr(addrinfo),
      ptr(ptr(addrinfo)),
    ->
      i32

extern
  socket
    <-
      u32,
      u32,
      u32,
    ->
      i32

extern
  bind
    <-
      i32,
      ptr(sockaddr),
      u32,
    ->
      u32

extern
  listen
    <-
      i32,
      i32,
    ->
      i32

extern
  accept
    <-
      i32,
      ptr(sockaddr),
      ptr(u32),
    ->
      i32

extern
  close
    <-
      i32,
    ->
      i32

constant
  epollin
    1

constant
  epollpri
    2

constant
  epollout
    4

constant
  epollerr
    8

constant
  epollhup
    16

constant
  epollrdnorm
    64

constant
  epollrdband
    128

constant
  epollwrnorm
    256

constant
  epollwrband
    512

constant
  epollmsg
    1024

constant
  epollrdhup
    8192

constant
  epollexclusive
    268435456

constant
  epollwakeup
    536870912

constant
  epolloneshot
    1073741824

constant
  epollet
    2147483648

constant
  epoll_ctl_add
    1

constant
  epoll_ctl_del
    2

constant
  epoll_ctl_mod
    3

struct
  epoll_event
    events: u32,
    data: u64,

extern
  epoll_create1
    <-
      i32,
    ->
      i32

extern
  epoll_ctl
    <-
      i32,
      i32,
      i32,
      ptr(epoll_event),
    ->
      i32

extern
  epoll_wait
    <-
      i32,
      ptr(epoll_event),
      i32,
      i32,
    ->
      i32

extern
  memchr
    <-
      ptr(i8),
      i32,
      u64,
    ->
      ptr(i8)

extern
  puts
    <-
      ptr(i8),
    ->
      void

extern
  putchar
    <-
      u32,
    ->
      void

extern
  putint
    <-
      i32,
    ->
      void

extern
  putu64
    <-
      u64,
    ->
      void

struct
  chunk_t
    data: ptr(i8),
    size: u64,

enum
  partial_http_result_t
    method_chunk(chunk_t),
    method_end(),
    request_uri_chunk(chunk_t),
    request_uri_end(),
    header_key_chunk(chunk_t),
    header_key_end(),
    header_value_chunk(chunk_t),
    header_value_end(),
    body_chunk(chunk_t),
    body_end(),

enum
  partial_result_t
    continue(),
    part(partial_http_result_t),

define
  initialize_accept_socket
    ->
      i32
    = {
      let err: i32 = -1;
      let addr: ptr(addrinfo) = null;
      let hints =
        addrinfo(
          ai_passive,
          af_inet,
          sock_stream,
          0,
          0,
          null,
          null,
          null,
        );
      puts("getaddrinfo\00");
      if (getaddrinfo(null, "5000\00", &hints, &addr) != 0) {
        return err;
      }

      let accept_sock: i32 = 0;
      loop {
        puts("socket\00");
        accept_sock = socket(af_inet, sock_stream, default_protocol);
        if (accept_sock >= 0) {
          puts("bind\00");
          if (bind(accept_sock, (*addr).ai_addr, (*addr).ai_addrlen) == 0) {
            puts("found a socket\00");
            break;
          }
        }

        addr = (*addr).ai_next;
        if (addr == null) {
          puts("failed to find an addr\00");
          return err;
        }
      }

      puts("listen\00");
      if (listen(accept_sock, 1024) != 0) {
        return err;
      }

      return accept_sock;
    }

define
  main_loop
    <-
      accept_sock: i32,
      epoll_sock: i32,
    ->
      void
    = {
      loop {
        puts("epoll_wait\00");
        let events: array(epoll_event, 1024);
        let num_ready = epoll_wait(epoll_sock, &events[0], 1000, -1);
        if (num_ready < 0) {
          puts("problem\00");
          return void;
        }

        putint(num_ready);
        let i: i32 = 0;
        loop {
          if (i >= num_ready) {
            puts("breaking\00");
            break;
          }
          putint(i);
          let event = events[i];
          i = i + 1;

          let fd = event.data as i32;
          if (event.events & epollin != 0) {
            if (fd == accept_sock) {
              puts("new connection available\00");
              let new_connection = accept(accept_sock, null, null);
              let event = epoll_event(epollin, new_connection as u64);
              epoll_ctl(epoll_sock, epoll_ctl_add, new_connection, &event);
            } else {
              puts("connection ready to read\00");
              let buffer: [1024 x u8];
              let length_received = recv(fd, &buffer[0], 1000, msg_dontwait);
              putint(fd);
            }
          }
        }
      }
    }

define
  test_loop
    = {
      let i: i32 = 0;
      loop {
        if (i >= 5) {
          puts("breaking\00");
          break;
        } else {
          puts("not breaking\00");
        }
        putint(i);
        i = i + 1;
      }
      return void;
    }

define
  main
    = {
      test_loop();

      let accept_sock = initialize_accept_socket();
      if (accept_sock < 0) {
        return void;
      }

      let epoll_sock = epoll_create1(0);
      if (epoll_sock < 0) {
        return void;
      }

      let event = epoll_event(epollin, accept_sock as u64);
      putint(accept_sock);
      putu64(accept_sock as u64);
      epoll_ctl(epoll_sock, epoll_ctl_add, accept_sock, &event);

      main_loop(accept_sock, epoll_sock);
      return void;
    }

# define
#   parse_request
#     <=
#       chunk_t
#     =>
#       partial_result_t
#     = {
#       let chunk = yield continue();
#       loop {
#         let outcome = memchr(chunk.data, ' ' as i32, chunk.size);
#         if (outcome == null) {
#           yield part(method_chunk(chunk));
#         } else {
#           let new_size = outcome as u64 - chunk.data as u64;
#           yield part(method_chunk(chunk_t(chunk.data, new_size)));
#           yield part(method_end());
#           break;
#         }
#         chunk = yield continue();
#       }
#     }
# 
# define
#   main
#     = {
#       let coroutine = parse_request();
#       let empty = chunk_t(null, 0);
#       let test = "GET ";
#       let response =
#         resume@(chunk_t, partial_result_t, void)(coroutine, chunk_t(test, 4));
#       response =
#         resume@(chunk_t, partial_result_t, void)(coroutine, empty);
#     }
